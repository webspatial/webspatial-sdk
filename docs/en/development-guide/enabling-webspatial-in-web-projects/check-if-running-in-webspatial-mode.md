# Check If Running in WebSpatial Mode

Currently located in: [Step&nbsp;3: Integrate WebSpatial SDK into Web Build Tools](step-3-integrate-webspatial-sdk-into-web-build-tools.md)

---

The previous section, **[Generate a WebSpatial-Specific Website](generate-a-webspatial-specific-website.md)**, explained that WebSpatial SDK can automatically build two sets of site assets:

* One set targets desktop/mobile platforms and regular browsers and **does not** include the [WebSpatial SDK](../../core-concepts/unique-concepts-in-webspatial.md#webspatial-sdk).
* The other set targets the [WebSpatial App Shell](../../core-concepts/unique-concepts-in-webspatial.md#webspatial-sdk) and **does** include the WebSpatial SDK.

Your own application code may also contain logic that is specific to WebSpatial apps, such as:

* Spatial UI that differs greatly from a normal web UI
* 3D content unique to WebSpatial apps

> Example project: <https://github.com/webspatial/sample-techshop>
> | ![](../../../assets/concepts/3-12.png) | ![](../../../assets/concepts/3-13.png) |
> |:---:|:---:|

This code shouldn't run or even be included in the build for the desktop/mobile platform and regular browsers.

To achieve this optimization, confidently leverage spatial features and innovate freely, you need a reliable way to know whether the code is running in a WebSpatial app or in a regular website.

<a id="js-solution"></a>
## Recommended JS solution

If your web project includes a Node.js-based server, you first need to decide whether you're using a [single-web-server mode](./generate-a-webspatial-specific-website.md#single-web-server) or [multi-web-server mode](./generate-a-webspatial-specific-website.md#multi-web-server).

In multi-web-server mode, the server for WebSpatial sets the [`$XR_ENV`](./generate-a-webspatial-specific-website.md#dedicated-dev-server) environment variable when it starts, so your server code can just check that variable to know if it's running in the WebSpatial-specific server.

If you're using a single-web-server mode, you'll need to check the User-Agent string in web requests at runtime to identify whether the request is coming from a regular browser or the [WebSpatial App Shell](../../core-concepts/unique-concepts-in-webspatial.md#webspatial-sdk).

<a id="ua"></a>
### WebSpatial-specific UA string

For [Packaged WebSpatial Apps](../../core-concepts/unique-concepts-in-webspatial.md#webspatial-sdk) on visionOS generated by [WebSpatial Builder](./step-2-add-build-tool-for-packaged-webspatial-apps.md), the UA string is as follows:


```
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7; wv)
AppleWebKit/605.1.15 (KHTML, like Gecko)
WebSpatial/0.1.17
```

For third-party browsers that support WebSpatial apps on visionOS (with built-in WebSpatial App Shell, currently in development), the UA string is as follows:

```
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)
AppleWebKit/605.1.15 (KHTML, like Gecko)
WebSpatial/0.1.17 Safari/605.1.15
```

<a id="client-js-solution"></a>
### For client-side JS

In client-side JS, you can either check the [UA string](#ua) at runtime to see if the code is running in a WebSpatial app, or inject the [`$XR_ENV`](./generate-a-webspatial-specific-website.md#dedicated-dev-server) environment variable during the build so it's available as a constant in your client-side code.

> [!TIP]
> In Vite you can access it directly with `import.meta.env.XR_ENV`, no extra config needed.

You can also inject other constants derived from **`$XR_ENV`**.

For example, if you use client-side routing, it is best to inject a **`__XR_ENV_BASE__`** constant:

```diff
// https://vite.dev/config/
export default defineConfig({
+ define: {
+   __XR_ENV_BASE__: process.env.XR_ENV
+     ? JSON.stringify(`/webspatial/${process.env.XR_ENV}`)
+     : undefined,
+ },
  plugins: [
```

> [!NOTE]
> The [WebSpatial's plugins for web build tools](./add-optimizations-and-defaults-to-web-build-tools.md) automatically inject **`__XR_ENV_BASE__`**, so you can skip the manual config above.

See the usage example in the **[Quick Example](../quick-start/README.md)**.

```jsx
<Router basename={__XR_ENV_BASE__}>
```
```jsx
 <button
   onClick={() => {
     window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
   }}>
```

<a id="css-solution"></a>
## Recommended CSS solution

### A future standardizable approach

> [!WARNING]
> This API is **not** yet supported by WebSpatial SDK.

<details>
<summary>Use a media query in CSS to match the <code>space</code> color scheme:</summary>

On spatial-computing platforms the background environment color is unpredictable and changes with viewpoint and location, so the classic light/dark mode does not apply.

The WebSpatial API introduces a new color scheme called **`space`**, which is recognized only in WebSpatial apps. You can use it to target WebSpatial-specific CSS rules.

```css
@media (prefers-color-scheme: space) {
```
</details>

### A practical solution for now

Configure your web build tool so that **`$XR_ENV`** is injected into HTML.

E.g. with [Vite](./add-optimizations-and-defaults-to-web-build-tools.md):

1. Install the **vite-plugin-html** plugin.

```shell
pnpm add -D  vite-plugin-html
```

2. Update `vite.config.js`.

```diff
+import { createHtmlPlugin } from "vite-plugin-html";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
+   createHtmlPlugin({
+     inject: {
+       data: {
+         XR_ENV: process.env.XR_ENV,
+       },
+     },
+   }),
```

3. Modify the HTML template and add a class name that is only present when **`XR_ENV`** indicates spatial mode, for example on `<html>`.

```diff
+<%- XR_ENV === 'avp' ? `
+<html lang="en" class="is-spatial">
+ ` : `
  <html lang="en">
+   ` %>
```

In your CSS, wrap any WebSpatial-specific rules under `html.is-spatial`.

```css
html.is-spatial {
  .my-card {
```

---

Next chapter: [Using the WebSpatial API](../using-the-webspatial-api/README.md)
