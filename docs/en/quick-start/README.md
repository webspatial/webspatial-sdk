![status: preview](https://img.shields.io/badge/status-preview-orange)
> ⚠️ This project is in **preview**. Expect some missing docs and potential stability issues. APIs and features may change.

<div align="center">
  <img src="../../assets/logo.png" alt="WebSpatial Logo" width="400"/>

  [中文文档](../../zh/quick-start/README.md)
</div>

# Quick Start

> Previous chapter: [What Is WebSpatial](../introduction/README.md)

Use a minimal example to get hands-on with the [WebSpatial SDK](), covering project setup, SDK installation and configuration, a sample development workflow, and a preview of spatial features.

> [!IMPORTANT]
> To keep this guide short, clear, and results-oriented, no explanations are given here.
> Many steps are mandatory, so follow them exactly to ensure everything runs correctly.
> After you have completed the demo, refer to the more comprehensive [Development Guide]() for real-world projects, full option descriptions, and detailed explanations.
> Several links in this document point to additional details. If you just want to try the demo quickly, feel free to skip those links for now.

## 1. Create a modern Web project that supports WebSpatial

First confirm that Node.js is installed (see the [Node.js official website]()).

Using a standard React + Vite + TypeScript project as an example, run the following commands to create the project:

```shell
npx create-vite --template react-ts
```

In the project root, install the dependencies:

```shell
npm install
```

## 2. Install the WebSpatial SDK

```shell
npm install --save @webspatial/react-sdk @webspatial/core-sdk @google/model-viewer three
npm install --save-dev @webspatial/builder @webspatial/platform-visionos @webspatial/vite-plugin vite-plugin-html
```

> [!TIP]
> See [which dependencies are installed]() for details.

## 3. Integrate the WebSpatial SDK into the Web build tool (Vite)

First modify `tsconfig.app.json` and `tsconfig.node.json`, adding the configuration that [affects JSX compilation]().

```diff
{
  "compilerOptions": {
+   "jsxImportSource": "@webspatial/react-sdk",
```

Then modify `vite.config.ts`:

- Add the [WebSpatial Vite plugin]().
- Inject the [environment variable `$XR_ENV`]() into HTML.

```diff
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
+import webSpatial from "@webspatial/vite-plugin";
+import { createHtmlPlugin } from "vite-plugin-html";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
+   webSpatial(),
+   createHtmlPlugin({
+     inject: {
+       data: {
+         XR_ENV: process.env.XR_ENV,
+       },
+     },
+   }),
  ],
});
```

Run the Dev Server for desktop/mobile and other non-XR platforms (keep it running in the following steps):

```shell
npm run dev
```

![](../../assets/quick/1.png)

Open the URL shown in the terminal in a desktop browser such as Chrome to confirm everything works:

![](../../assets/quick/2.png)

Next, open a new terminal window (in the project root) and run another Dev Server to generate [Web-only code for WebSpatial](), used as a WebSpatial app on visionOS (keep it running in the following steps):

```shell
XR_ENV=avp npm run dev
```

![](../../assets/quick/3.png)

## 4. Package and run the WebSpatial app

Before using the [WebSpatial packaging tool](), install Xcode and the visionOS simulator:

> Prerequisite: a Mac computer
> 1. Open the Mac App Store, search for 'Xcode', and install it.
> 2. On first launch, agree to the license and enter the admin password to install additional components.
> 3. Click the top menu 'Xcode' > 'Settings…'. In the 'Components' tab under 'Platform Support', locate visionOS and visionOS Simulator, then install both.

Run the [development command]() of the WebSpatial packaging tool:

```shell
npx webspatial-builder run --base=$XR_DEV_SERVER
```

> [!TIP]
> Replace `$XR_DEV_SERVER` with the URL generated by `XR_ENV=avp npm run dev` in the previous step.

The visionOS simulator launches automatically, installs the packaged WebSpatial app, and runs it:

![](../../assets/quick/4.png)
![](../../assets/quick/5.png)

## 5. Set initialization properties for the launch scene

Create a minimal [Web App Manifest file]() (only for the `webspatial-builder run` command; [complete it before real-device runs or distribution]()).

```shell
touch public/manifest.webmanifest
```

In `xr_main_scene`, set the [launch scene]()[default size]():

```json5
{
  "xr_main_scene": {
    "default_size": {
      "width": 500,
      "height": 1000
    }
  }
}
```

Run the WebSpatial packaging tool (`run` command) again. The app’s launch scene now appears with a mobile-app-style layout:

> [!WARNING]
> A current bug may leave the launch scene blank after repackaging. If this happens, delete the app in the simulator, quit the simulator, then package and run again.
> If the issue persists, delete `node_modules` in the project and reinstall dependencies.

![](../../assets/quick/6.png)

## 6. Add a new scene

First add a new page. In this demo we use client-side routing.

Create `src/SecondPage.tsx`.

```jsx
import { useState } from "react";
import "./App.css";

function SecondPage() {
  const [count, setCount] = useState(0);

  return (
    <div className="App">
      <h1>Second Page</h1>
      <div className="card">
        <button onClick={() => setCount(count => count + 1)}>
          count is {count}
        </button>
      </div>
    </div>
  );
}

export default SecondPage;
```

Add the following to `src/App.tsx`.

```jsx
import { BrowserRouter as Router, Routes, Route, Link } from "react-router-dom";
import SecondPage from "./SecondPage";
```

Install a library that supports client-side routing.

```shell
npm install --save react-router-dom
```

Move all existing JSX in `src/App.tsx` into the designated position in the new JSX:

```diff
  return (
+   <Router basename={__XR_ENV_BASE__}>
+     <Routes>
+       <Route path="/second-page" element={<SecondPage />} />
+       <Route
+         path="/"
+         element={
            /* 把 src/App.tsx 中 App 组件原有的 JSX 内容全部放到这里 */
+         }
+       />
+     </Routes>
+   </Router>
  );
```

> [!TIP]
> What is `__XR_ENV_BASE__`()?

The new page `/second-page` has been added:

![](../../assets/quick/7.png)

At the end of the existing content in `src/App.tsx` (below `<p className="read-the-docs">`), add a card containing:

- A link that always opens `/second-page` in a new window.
- A button that opens `/second-page` in a window with the specified `name`.

```diff
              <p className="read-the-docs">
                Click on the Vite and React logos to learn more
              </p>
+             <div className="card" style={{ marginTop: "0px" }}>
+               <h2>Open Second Page</h2>
+               <p>
+                 <Link to="/second-page" target="_blank">
+                   Open Second Page with a Link
+                 </Link>
+               </p>
+               <p>
+                 <button
+                   onClick={() => {
+                     window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
+                   }}>
+                   Open Second Page with a Button
+                 </button>
+               </p>
+             </div>
```

Clicking the link or button opens a new [spatial-app scene]() that displays the content of `/second-page`:

![](../../assets/intro/intro-4-8.gif)

## 7. Set initialization properties for the new scene

Import the [scene initialization]() API from the WebSpatial SDK in `src/App.tsx`.

```jsx
import { initScene } from "@webspatial/react-sdk";
```

Before the scene with `name` equal to `"secondScene"` opens, initialize it:

```diff
                    onClick={() => {
+                     initScene("secondScene", prevConfig => {
+                       return {
+                         ...prevConfig,
+                         defaultSize: {
+                           width: 500,
+                           height: 500,
+                         },
+                       };
+                     });
                      window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
```

Click the button and see that the default size of the `secondScene` scene changes:

![](../../assets/quick/9.png)

## 8. Add material backgrounds

Modify `index.html` to add a `classname` specific to `XR_ENV` mode on `<html>`.

```diff
+<%- XR_ENV === 'avp' ? `
+<html lang="en" class="is-spatial">
+  ` : `
   <html lang="en">
+    ` %>
```

At the end of `src/index.css`, add code that sets the scene background in `XR_ENV` mode to a [fully transparent material]() (using [--xr-background-material]() from the WebSpatial API):

```css
html.is-spatial {
  background-color: transparent;
  --xr-background-material: transparent;
}
```

> [!TIP]
> Although style changes take effect automatically via the Dev Server, HMR for WebSpatial logic in React components is not yet supported. If logic changes, refresh manually (via the scene menu in the bottom right) or restart the Dev Server to see updates.

| ![](../../assets/quick/10.png) | ![](../../assets/quick/11.png) |
| :----------------------------: | :----------------------------: |

Modify `src/App.tsx` to make the two card elements [spatialized HTML elements]() by adding a `classname`.

Spatialize the link inside `link-card` as well.

```diff
              <h1>Vite + React</h1>
-             <div className="card">
+             <div className="card count-card" enable-xr>
```

```diff
-             <div className="card">
+             <div className="card link-card" enable-xr>
                <h2>Open Second Page</h2>
                <p>
-                 <a href="/second-page" target="_blank">
+                 <a href="/second-page" target="_blank" enable-xr>
                    Open Second Page with a Link
                  </a>
```

In the [styles for `XR_ENV` mode]() in `src/index.css`, set different [translucent materials]() for the backgrounds of the two card elements and for the link inside `link-card`:

```css
html.is-spatial {
  background-color: transparent;
  --xr-background-material: transparent;

  .count-card {
    --xr-background-material: thick;
    position: relative;
  }

  .link-card {
    --xr-background-material: translucent;
    border-radius: 20px;
    position: relative;
    top: 20px;

    a {
      display: block;
      --xr-background-material: thick;
      border-radius: 10px;
    }
  }
}
```

| ![](../../assets/quick/12.png) | ![](../../assets/quick/13.png) |
| :----------------------------: | :----------------------------: |

## 9. 'Elevate' spatialized elements

Mark the description text inside `count-card` as a [spatialized HTML element]().

```diff
-               <p>
+               <p enable-xr>
                  Edit <code>src/App.tsx</code> and save to test HMR
                </p>
```

In the [`XR_ENV` mode styles]() in `src/index.css`, change this element to `position: relative` and use the WebSpatial Z-axis positioning API (`--xr-back`) to 'elevate' it into 3D space in front of the web plane.

Apply different levels of 'elevation' to the link elements spatialized earlier.

```diff
  .count-card {
    --xr-background-material: thick;
    position: relative;

+   p {
+     --xr-background-material: transparent;
+     position: absolute;
+     bottom: -10px;
+     left: 0;
+     right: 0;
+     --xr-back: 20;
+   }
  }

  .link-card {
    --xr-background-material: translucent;
    border-radius: 20px;
    position: relative;
+   --xr-back: 50;
    top: 20px;
```

| ![](../../assets/quick/14.png) | ![](../../assets/quick/15.png) |
| :----------------------------: | :----------------------------: |

Another way to 'elevate' is to use CSS Transform, which can also [deform and rotate]() in 3D space.

In the [`XR_ENV` mode styles]() in `src/index.css`, move and rotate `link-card` along the Z axis (around the X axis):

```diff
  .link-card {
    --xr-background-material: translucent;
    border-radius: 20px;
    position: relative;
    --xr-back: 50;
    top: 20px;
+   transform-origin: top left;
+   transform: translateZ(30px) rotateX(30deg);
```

| ![](../../assets/quick/16.png) | ![](../../assets/quick/17.png) |
| :----------------------------: | :----------------------------: |

## 10. Add static 3D content

> To be added

## Final result

The full source code for this demo is in the repository:
<https://github.com/webspatial/quick-example>

Follow the README to run it and view the result on the visionOS simulator or a physical device.

---

Next chapter: Learn more about WebSpatial’s [Core Concepts](../core-concepts/README.md)
